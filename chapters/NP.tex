\setchapterstyle{kao}
\setchapterpreamble[u]{\margintoc}
\chapter{Теория NP-полноты}
\labch{mathematics}

\section{Два подхода к сложности задачи}
\labsec{two-difficulty-approarch}
Первый подход предлагает считать сложностью алгоритма число тактов работы
машины, реализующей этот алгоритм (число тактов работы в Машине Тьюринга, число
совершённых подстановок в НАМ, число команд выполненных РАМ).

Второй подход предлагает рассматривать в качестве алгоритма булеву функцию,
реализующую этот алгоритм, и в качестве сложности рассматривать число
функциональных элементов в схеме из функциональных элементов, реализующих эту
функцию. \sidenote{Подробнее об этом подходе мы поговорим в соответствующей главе.}

В любом случае понятно, что для разных индивидуальных задач I сложность будет разной. 

Возьмём все индивидуальные задачи $I$ с входом длины $|I| \le m$. Число таких
задач обозначим $Z_n$. Очевидно, что для конечного алфавита число $Z_n$ --- конечно. 

\begin{definition}
	Сложность в худшем назовём $t_Z(n) = \max_{|I|\le n} t(I)$. \marginnote{Максимальное
	время работы алгоритма на индивидуальных задачах $I$ с длиной входа $|I|
	\le n$.}
\end{definition}

\begin{definition}
	Сложностью в среднем назовём \[
		\frac{\sum\limits_{|I|\le n} t\left( I \right) }{Z_n}
	.\] 
\end{definition}

Для каждой задачи может быть сколь угодно много различных алгоритмов $A_Z^1,
A_Z^2, \ldots$. 
\begin{definition}
	Сложность задачи --- наилучшая из сложностей алгоритмов, решающих эту
	задачу.
\end{definition}

\begin{definition}
	Будем называть задачу трудно разрешимой, если у всех алгоритмов,
	решающих её, сложность по меньшей мере экспоненциальная. \cite{Aho}
\end{definition}
Для сравнения масштабов, если 1 такт занимает $10^{-6}$ секунд, то для входа
длины 60 алгоритм со сложностью  $n^6$ будет работать 13 минут, а со сложностью
$2^n$ --- 366 веков.
\marginnote[-0.7cm]{Сравнение графиков функций $x^2$ и  $2^x$ как пример,
насколько сильна разница между экспоненциальной и полиномиальной
сложностью. Сравните рост значений в
окрестности 10, например.}

\begin{marginfigure}[-5.5cm]
	\includegraphics{xpow2and2powx.png}
	\caption{График функций $2^x$ и $x^2$ }
\end{marginfigure}

При этом развитие техники на время работы экспоненциальных алгоритмов никак
влиять не будет. Даже при увеличении мощностей в 1000 раз, экспоненциальный
алгоритм будет работать за адекватное время на задаче с длиной входа на 10
символов больше, чем сейчас.\sidenote{Пусть сейчас наибольшая задача, которая решается за
	допустимое время имеет размер n, тогда при увеличении мощностей в 1000
	раз мы имеем прирост в $\log_2 1000 \simeq 10$
}


\section{Определение классов P, NP}
\labsec{P-NP-def}

\begin{definition}
	Слово из входных символов допускается (воспринимается) тогда и только
	тогда, когда машина Тьюринга, начав работу в выделенном начальном
	состоянии, сделаем последовательность шагов, которые в конце концов
	приведут её в допускающее состояние.
\end{definition}
\begin{definition}
	Языком L(M), допускаемым машиной M, называют множество всех цепочек
	(слов) из входных символов, допускаемых M.
\end{definition}

\begin{definition}
	Класс P --- это класс языков, допускаемых МТ за полиномиальное
	время. 
\end{definition}
\marginnote[*-2]{То есть МТ допускает язык и её время работы ограничено
	полиномом.}
Задачи (языки) из класса P называются полиномиально разрешимыми.
\begin{definition}
	Класс NP --- класс языков, допускаемых НМТ за полиномиальное время.
\end{definition}

\begin{theorem}
	Если $Z\in NP$, то существует такой полином  $p(n)$, что Z может быть
	решена на детерминированной МТ за время  $O(2^{p(n)})$.
\end{theorem}
\begin{proof}
Если Z решается на НМТ за полином $q\left( n \right) $, то значит для каждой I
найдётся отгадка U(I) после записи которой НМТ будет работать как обычная МТ и
будет проверять отгадку. Время проверки отгадки, написанной
угадывающей головкой --- $O(q(n))$, а значит и длина отгадки --- $O(q(n))$. 

Для перебора всех отгадок понадобится в алфавите длины k потребуется $k^{q(n)}$,
а значит в сочетании с
проверкой всё займёт $O(k^{q(n)}*q(n)) = O(2^{p(n)})$\sidenote[*]{Просто возьмём
достаточно большой полином}.
\end{proof}

\section{Полиномиальная сводимость}

\begin{definition}
	Язык $L_1 \subset A^*$ сводится к языку $ L_2 \subset B^*$, если
	существует такое отображение $f: A^* \to B^*$, что выполняются два
	условия.
	\begin{enumerate}
		\item Функция f вычисляется за полиномиальное время. (Например,
			существует МТ, которая за полиномиальное число тактов
			вычисляет эту функцию.)
		\item Для любого входа $I\in A^*$ соотношение $I\in L_1$
			выполняется тогда и только тогда, когда выполняется
			соотношение  $f(I)\in~L_2.$
	\end{enumerate}
\end{definition}
\marginnote[-4cm]{Мы знаем, что произведение двух полиномов и полином от
	полинома также будет полиноном. Получается, если задача $Z_1$ имеет
	полиномиальную сложность $O(p(n))$, то, если $Z_2$ полиномиально сводится к  $Z_1$
	за $O(q(n))$, то сложность $Z_2$ будет $O(p(q(n))$.
}
\marginnote{
	Логично, что если задача может быть
	сведена к другой за время не меньшее, чем экспоненциальное время, то о
	принадлежности одним классам говорить нечего. 
}

Полиномиальную сводимость будем обозначать $\le_P$.


\begin{lemma}
	Если $Z_1 \le_P Z_2$ и  $Z_2 \le_P Z_3$, то $Z_1 \le_P Z_3$
\end{lemma}
\begin{proof}
	Пусть $Z_1 \le_P Z_2$ путём отображения f, а  $Z_2 \le_P Z_3$ --- g.
	Тогда рассмотрим суперпозицию gf, которое будет сводить $Z_1$ к  $Z_3$.
	При этом, так как f и g полиномы, то и их композиция тоже будет
	полиномом.
\end{proof}
\begin{lemma}
\lablemma{polynom-P}
	Пусть $Z_2 \in P$, и  $Z_1 \le_P Z_2$. Тогда  $Z_1 \in P$.
\end{lemma}
\begin{proof}
	Пусть A и B --- алфавиты языков $L_1$ и $L_2$, а функция $f: A^* \to
	B^*$ осуществляет полниномиальную сводимость $L_1$ к $L_2$.

	$Z_2\in P$, значит существует машина Тьюринга $M_2$, решающая  $Z_2$ за
	$O(p(n))$ тактов.
	$M_f$ --- машина Тьюринга, реализующая функцию f, работающая за
	$O(q(n))$ тактов.
	
	Тогда композиция Машин Тьюринга $M_1 = M_2M_t$, которая сначала
	преобразует (сведёт) условие задачи $Z_1$ к условию $Z_2$, а потом решит
	её, будет работать за полином.

\end{proof}
\marginnote[-2.5cm]{Если попросили решить задачу, которая может быть полиномиально сведена к уже
известной задаче из P, то можно радоваться и писать решение за полином.}

\section{Класс NPC}
\labsec{NPC}
\begin{definition}
	Класс NPC (NP Complete) --- класс таких задач, что для любой задачи
	$Z\in NPC$ выполнено условие, что $Z\in NP$ и $\forall Z'\in NP, Z'
	\le_P Z$.
\end{definition}

\begin{lemma}
	Если $Z\in NPC$ и  $Z \le_P Z'$, то  $Z' \in NPC$
\end{lemma}
\marginnote[-0.7cm]{Доказательство этого факта очевидно и прямо следует из
определения.}

\input{chapters/CookTheorem.tex}
